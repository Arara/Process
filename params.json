{"name":"Process","tagline":"Provides a better API to work with processes on Unix-like systems using PHP.","body":"# Arara\\Process\r\n[![Build Status](https://scrutinizer-ci.com/g/Arara/Process/badges/build.png?b=master)](http://travis-ci.org/Arara/Process \"Build Status\")\r\n[![Code Quality](https://scrutinizer-ci.com/g/Arara/Process/badges/quality-score.png?b=master)](https://scrutinizer-ci.com/g/Arara/Process/?branch=master \"Code Quality\")\r\n[![Code Coverage](https://scrutinizer-ci.com/g/Arara/Process/badges/coverage.png?b=master)](https://scrutinizer-ci.com/g/Arara/Process/?branch=master \"Code Coverage\")\r\n[![Total Downloads](https://poser.pugx.org/arara/process/downloads.png)](https://packagist.org/packages/arara/process \"Total Downloads\")\r\n[![License](https://poser.pugx.org/arara/process/license.png)](https://packagist.org/packages/arara/process \"License\")\r\n[![Latest Stable Version](https://poser.pugx.org/arara/process/v/stable.png)](https://packagist.org/packages/arara/process \"Latest Stable Version\")\r\n[![Bitdeli Badge](https://d2weczhvl823v0.cloudfront.net/Arara/process/trend.png)](https://bitdeli.com/free \"Bitdeli Badge\")\r\n\r\nThis library provides a better API to work with processes on Unix-like systems using PHP.\r\n\r\n## Installation\r\n\r\nThe package is available on [Packagist](https://packagist.org/packages/arara/process). You can install it using\r\n[Composer](http://getcomposer.org).\r\n\r\n```bash\r\ncomposer require arara/process\r\n```\r\n\r\n### Dependencies\r\n\r\n- PHP 5.4+\r\n- [PCNTL](http://php.net/pcntl)\r\n- [POSIX](http://php.net/posix)\r\n- [PHPFluent\\Callback](https://github.com/PHPFluent/Callback) (installed by Composer)\r\n\r\nVersion [1.6.0](https://github.com/Arara/Process/tree/1.6.0) or less of Arara\\Process works on PHP 5.3.\r\n\r\n## Usage\r\n\r\nAlong with this document, there are many usage examples in the [examples/](examples/) directory which may be used for reference.\r\n\r\nAll examples within this document assume you have the following statement at the beginning of the file:\r\n\r\n```php\r\ndeclare(ticks=1);\r\n```\r\n\r\nWithout this statement, there is no guarantee PHP will handle signals; this is very important for PCNTL to work properly.\r\nIt has been required since version 4.3.0 of PHP, so this is not a request of the library but of the PHP language itself.\r\n\r\nIf you want to know more about _ticks_, we recommend you read http://php.net/declare#control-structures.declare.ticks.\r\n\r\n### Action interface\r\n\r\nForks may be encapsulated using `Arara\\Process\\Action\\Action` interface.\r\nAll classes that implements this interface must implement two methods:\r\n\r\n- `execute(..)`: may contain the action performed in the background\r\n- `trigger(...)`: may contain specific actions to events\r\n\r\nUsing this interface you can create your own actions and run them in the background.\r\n\r\n### Events\r\n\r\nThe `Arara\\Process\\Action\\Action::trigger(..)` method, as it is written, associates specific actions with events.\r\nThose events can be:\r\n\r\n- `Action::EVENT_INIT`: triggered when action is initialized\r\n    - When the action is attached to a Child object\r\n- `Action::EVENT_FORK`: triggered when action is forked\r\n    - After the action is forked it is triggered on the **parent** process\r\n- `Action::EVENT_START`: triggered before the execute() method is executed\r\n- `Action::EVENT_SUCCESS`: triggered when the action is finished with success, that is:\r\n    - When the action does not encounter a PHP error\r\n    - When the action does not throw an exception\r\n    - When the action does not return any value\r\n    - When the action returns an `Action::EVENT_SUCCESS` value\r\n- `Action::EVENT_ERROR`: triggered when the action is encounters an error, that is:\r\n    - When the action encounters a PHP error\r\n    - When the action returns an `Action:EVENT_ERROR` value\r\n- `Action::EVENT_FAILURE`: triggered after the action has finished and failed, that is:\r\n    - When the action throws an exception\r\n    - When the action returns an `Action::EVENT_FAILURE` value\r\n- `Action::EVENT_TIMEOUT`: triggered when the action experiences a timeout\r\n- `Action::EVENT_FINISH `: triggered after the execute() method has executed.\r\n\r\n### Callback action\r\n\r\nIn order to make it easy to execute forks with no need to create a specific class to execute something in the background, there\r\nis a generic implementation that allows a callback to be run in the background; the only thing one must do is pass the callback\r\nto the constructor of this class.\r\n\r\n```php\r\nuse Arara\\Process\\Action\\Callback;\r\n\r\n$callback = new Callback(function () {\r\n    echo \"This will be executed in the background!\" . PHP_EOL;\r\n});\r\n```\r\n\r\nThe Callback action provides a way to bind callbacks to be triggered by specific events:\r\n\r\n```php\r\n$callback->bind(Callback::EVENT_SUCCESS, function () {\r\n    echo \"This will be executed if the action callback was successful!\" . PHP_EOL;\r\n});\r\n```\r\n\r\nAlso, one can bind a callback to multiple events:\r\n\r\n```php\r\n$callback->bind(Callback::EVENT_ERROR | Callback::EVENT_FAILURE, function () {\r\n    echo \"It is going to be executed if the action fails or get an error\" . PHP_EOL;\r\n});\r\n```\r\n\r\n### Command action\r\n\r\nYou may want to run just a Linux command, for that reason there is Command action.\r\n```php\r\n$command = new Command('whoami');\r\n```\r\n\r\nUsing Command action you can define arguments as second param:\r\n```php\r\n$command = new Command('cp', array('/path/to/source', '/path/to/destination'));\r\n```\r\n\r\nIf you prefer arguments can be defined by a key => value array:\r\n```php\r\n$command = new Command(\r\n    'find',\r\n    array(\r\n        '/path/to/dir',\r\n        '-name' => '*',\r\n        '-type' => 'f',\r\n    )\r\n);\r\n```\r\n\r\nCommand action is based on Callback action so you can also bind triggers for events.\r\n\r\n### Daemon action\r\n\r\nYou can create daemons using the `Arara\\Process\\Action\\Daemon` class:\r\n\r\n```php\r\n$daemon = new Daemon(\r\n    function (Control $control, Context $context, Daemon $daemon) {\r\n        while (! $daemon->isDying()) {\r\n            // Do whatever you want =)\r\n        }\r\n    }\r\n);\r\n```\r\n\r\nThis action will:\r\n\r\n1. Detach process session from the parent\r\n2. Update process umask\r\n3. Update process work directory\r\n4. Define process GID (if defined)\r\n5. Define process UID (if defined)\r\n6. Recreate standards file descriptors (STDIN, STDOUT and STDERR)\r\n7. Create Pidfile\r\n8. Run the defined payload callback\r\n\r\nDaemon action is based on Callback action thus you can also bind triggers for events.\r\n\r\n#### Daemon options\r\n\r\nDaemon action class has some options that allows you to change some behaviours:\r\n\r\n- `name`: Name used by pidfile (default _arara_)\r\n- `lock_dir`: Lock directory for pidfile (default _/var_/run)\r\n- `work_dir`: Work directory (default _/_)\r\n- `umask`: Default umask value (default _0_)\r\n- `user_id`: When defined changed the daemon UID (default _NULL_)\r\n- `group_id`: When defined changed the daemon GID (default _NULL_)\r\n- `stdin`: File to use as `STDIN` (default _/dev/null_)\r\n- `stdout`: File to use as `STDOUT` (default _/dev/null_)\r\n- `stderr`: File to use as `STDERR` (default _/dev/null_)\r\n\r\nYou can change default daemon options by defining it on class constructor:\r\n```php\r\n$daemon = new Daemon(\r\n    $callback,\r\n    array(\r\n        'name' => 'mydaemonname',\r\n        'lock_dir' => __DIR__,\r\n    )\r\n);\r\n```\r\n\r\nAfter the object is created you may change all options:\r\n```php\r\n$daemon->setOptions(\r\n    array(\r\n        'stdout' => '/tmp/daemon.stdout',\r\n        'stderr' => '/tmp/daemon.stderr',\r\n    )\r\n);\r\n```\r\n\r\nAlso you can change just an option:\r\n```php\r\n$daemon->setOption('work_dir', __DIR__);\r\n```\r\n\r\n### Starting a process in the background\r\n\r\nThe class `Arara\\Process\\Child` allows you to execute any action in the background.\r\n\r\n```php\r\n$child = new Child(\r\n    new Daemon(function () {\r\n        // What my daemon does...\r\n    }),\r\n    new Control()\r\n);\r\n$child->start(); // Runs the callback in the background\r\n```\r\n\r\nThe above example runs the Daemon action in the background, but one can use any class which implements\r\nthe `Arara\\Process\\Action\\Action` interface like Callback action.\r\n\r\n### Check if the process is running\r\n\r\nChecking to see if a process is running is a very common routine; to perform this using this library you may call:\r\n\r\n```php\r\n$child->isRunning(); // Returns TRUE if it is running or FALSE if it is not\r\n```\r\n\r\nThis method not only checks the state of the object, but also checks to see if the process is already running on the system.\r\n\r\n### Terminating the process\r\n\r\nIf the process has already started, this tells the process to terminate, but does not force it.\r\n\r\n```php\r\n$child->terminate(); // Sends a SIGTERM to the process\r\n```\r\n\r\n### Killing the process\r\n\r\nIf it has already started, this forces the process to terminate immediately.\r\n\r\n```php\r\n$child->kill(); // Sends a SIGKILL to the process\r\n```\r\n\r\n### Waiting on the process\r\n\r\nIf you want to wait on the process to finish, instead of just starting the process in the background, you can call:\r\n\r\n```php\r\n$child->wait();\r\n```\r\n\r\nThe next line of code will be executed after the process finishes.\r\n\r\n### Getting a process' status\r\n\r\nIt is possible to get the status of a process after waiting for it finish.\r\nThe `Arara\\Process\\Child` class has a method `getStatus()` which allows you to check the status of a process.\r\n\r\n```php\r\n$child->getStatus(); // Returns an Arara\\Process\\Control\\Status instance\r\n```\r\n\r\nInternally, this calls the `wait()` method, in order to wait for the process to finish - and then get its status.\r\n\r\n#### Get the exit code of the process\r\n\r\n```php\r\n$child->getStatus()->getExitStatus();\r\n```\r\n\r\n#### Get the signal which caused the process to stop\r\n\r\n```php\r\n$child->getStatus()->getStopSignal();\r\n```\r\n\r\n#### Get the signal which caused the process to terminate\r\n\r\n```php\r\n$child->getStatus()->getTerminateSignal();\r\n```\r\n\r\n#### Checks if the status code represents a normal exit\r\n\r\n```php\r\n$child->getStatus()->isExited();\r\n```\r\n\r\n#### Checks whether the status code represents a termination due to a signal\r\n\r\n```php\r\n$child->getStatus()->isSignaled();\r\n```\r\n\r\n#### Checks whether the process is stopped\r\n\r\n```php\r\n$child->getStatus()->isStopped();\r\n```\r\n\r\n#### Checks if the process was finished successfully\r\n\r\n```php\r\n$child->getStatus()->isSuccessful();\r\n```\r\n\r\n### Spawning\r\n\r\nSince you are working with forks you are able work with spawn as well. The `Arara\\Process\\Pool` class provides a simple\r\nway to work with it.\r\n\r\nThis class handles the queue of process dynamically, the only thing you have to do is provide the limit of children you\r\nwant in the constructor and then attach the children.\r\n\r\n```php\r\n$maxConcurrentChildren = 2;\r\n$pool = new Pool($maxConcurrentChildren);\r\n$pool->start();\r\n\r\n$pool->attach(new Child(/* ... */));\r\n$pool->attach(new Child(/* ... */));\r\n$pool->attach(new Child(/* ... */));\r\n$pool->attach(new Child(/* ... */));\r\n// ...\r\n```\r\n\r\nThe number of children it has does not matter; it will only run 2 process simultaneously; when one of those process is\r\nfinished, it is removed from the queue and a new slot is opened.\r\n\r\nThe `Arara\\Process\\Pool` class contains most of the methods of `Arara\\Process\\Child` class:\r\n\r\n- `isRunning()`\r\n- `kill()`\r\n- `start()`\r\n- `terminate()`\r\n- `wait()`\r\n\r\nThis behaves similarly for all methods.\r\n\r\n### Control class\r\n\r\nYou can also handle processes without using Pool, Child or the Action classes.\r\n\r\nWe provide a simple API to work with the `pcntl_*` and `posix_*` functions. You can learn more by reading the\r\ncode of `Arara\\Process\\Control` and its dependencies, but here is an example:\r\n\r\n```php\r\n$control = new Control();\r\n$pid = $control->fork();// Throws RuntimeException when pcntl_fork() returns -1\r\nif ($pid > 0) {\r\n    echo 'Waiting on child...' . PHP_EOL;\r\n    $control->waitProcessId($pid);\r\n    echo 'Child finished' . PHP_EOL;\r\n    $control->quit();\r\n}\r\n\r\necho 'Child process has PID ' . $control->info()->getId() . PHP_EOL;\r\necho 'Child process has parent PID ' . $control->info()->getParentId() . PHP_EOL;\r\n\r\n$control->flush(2.5); // Will try to flush current process memory and sleep by 2 and a half seconds\r\n$control->signal()->send('kill'); // Will send SIGKILL to the current process (the child)\r\n```\r\n\r\n### Pidfile class\r\n\r\nIf you are working with background tasks you may want to create a lock to avoid people running your script twice. For this\r\npurpose there is the class `Arara\\Process\\Pidfile`.\r\n\r\n```php\r\n$control = new Control();\r\n$applicationName = 'my_app';\r\n$pidfile = new Pidfile($control, $applicationName);\r\n$pidfile->initialize();\r\n\r\n// Whatever you need here...\r\n\r\n$pidfile->finalize();\r\n```\r\n\r\nThe second time someone runs it an exception is thrown. We recommend you put this code into a `try..catch` statement.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}